---
title: "Social Technology for Programmers"
layout: post
categories: software
---

One of Samo Burja's most interesting articles is about the idea of [social technologies](https://samoburja.com/social-technology/) as a hidden bottleneck to the adoption of material technologies.

Burja points out many examples of social technology such as norms in medicine, law and ritual. Furthermore, Burja points out how social and material technology interact; by lowering the costs of coordination, social technology enables the formation of capital and production of material technology.

While those examples are great macro examples, we see the interaction of social and material technologies at the team level as well. A great example of this interaction is in attempts to measure a software engineering team's productivity. Bad metrics include lines of code, and better ones might involve a point system related to broader application or feature level development goals. In turn, these metrics lead to incentives (read: social technology) that naturally organize teams in certain ways and produce a certain quality of software (material technology).

As a result, measuring material production can only capture part of the story. Because, at its essence, software is about abstracting arbitrary rules into human-readable information, development requires systematic coordination to occur smoothly (i.e., adoption of social technologies). Along those lines, teams with a healthy engineering culture perform better on social technology measures: metrics around the ability of team members to step into new roles and transfer knowledge indicate the ability of the team to coordinate and deliver robust software.

In conclusion, social technology plays a crucial role within software teams. Another way to look at it is that software development is just a bunch of computer instructions, and coordinating those rules effectively requires adopting the right tools in helping others coordinate with you.
